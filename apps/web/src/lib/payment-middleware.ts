// x402 Payment Middleware
// Generated by Cradle

import type { FastifyRequest, FastifyReply, FastifyPluginCallback } from 'fastify';
import { createPublicClient, http } from 'viem';
import { arbitrum, arbitrumSepolia } from 'viem/chains';
import {
  type PaymentReceipt,
  type PaymentRequirements,
  type PaymentVerificationResult,
  createPaymentRequiredHeaders,
  parsePaymentReceipt,
} from './types';

const PAYMENT_REQUIREMENTS: PaymentRequirements = {
  address: process.env.PAYMENT_RECEIVER_ADDRESS!,
  amount: '1000000000000000',
  currency: 'ETH',
  chainId: parseInt(process.env.CHAIN_ID || '42161'),
  timeout: 300,
  
};

// Cache for verified receipts
const verifiedReceipts = new Map<string, { timestamp: number; valid: boolean }>();
const CACHE_TTL = 60 * 60 * 1000; // 1 hour

export async function verifyPayment(receipt: PaymentReceipt): Promise<PaymentVerificationResult> {
  // Check cache first
  const cached = verifiedReceipts.get(receipt.txHash);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return { valid: cached.valid, receipt: cached.valid ? receipt : undefined };
  }

  try {
    const chain = PAYMENT_REQUIREMENTS.chainId === 42161 ? arbitrum : arbitrumSepolia;
    const client = createPublicClient({
      chain,
      transport: http(),
    });

    // Get transaction receipt from chain
    const txReceipt = await client.getTransactionReceipt({
      hash: receipt.txHash as `0x${string}`,
    });

    if (!txReceipt) {
      return { valid: false, error: 'Transaction not found' };
    }

    // Verify transaction was successful
    if (txReceipt.status !== 'success') {
      return { valid: false, error: 'Transaction failed' };
    }

    
    // Verify payment details
    const tx = await client.getTransaction({
      hash: receipt.txHash as `0x${string}`,
    });

    if (tx.to?.toLowerCase() !== PAYMENT_REQUIREMENTS.address.toLowerCase()) {
      return { valid: false, error: 'Payment sent to wrong address' };
    }

    if (BigInt(tx.value) < BigInt(PAYMENT_REQUIREMENTS.amount)) {
      return { valid: false, error: 'Insufficient payment amount' };
    }

    // Verify timestamp is within timeout
    const block = await client.getBlock({ blockNumber: txReceipt.blockNumber });
    const txTimestamp = Number(block.timestamp);
    const currentTime = Math.floor(Date.now() / 1000);
    
    if (currentTime - txTimestamp > PAYMENT_REQUIREMENTS.timeout) {
      return { valid: false, error: 'Payment receipt expired' };
    }
    

    // Cache result
    verifiedReceipts.set(receipt.txHash, { timestamp: Date.now(), valid: true });
    
    return { valid: true, receipt };
  } catch (error) {
    console.error('Payment verification error:', error);
    return { valid: false, error: 'Verification failed' };
  }
}

export const paymentMiddleware: FastifyPluginCallback = (fastify, _opts, done) => {
  fastify.addHook('preHandler', async (request: FastifyRequest, reply: FastifyReply) => {
    // Skip for non-protected routes
    if (!request.url.startsWith('/api/premium/resource')) {
      return;
    }

    const receiptHeader = request.headers['x-payment-receipt'] as string | undefined;

    if (!receiptHeader) {
      // No payment receipt - return 402
      const headers = createPaymentRequiredHeaders(PAYMENT_REQUIREMENTS);
      
      for (const [key, value] of Object.entries(headers)) {
        reply.header(key, value);
      }

      return reply.status(402).send({
        error: 'Payment Required',
        message: 'This resource requires payment. Include X-Payment-Receipt header with valid payment proof.',
        requirements: PAYMENT_REQUIREMENTS,
      });
    }

    // Parse and verify receipt
    const receipt = parsePaymentReceipt(receiptHeader);
    
    if (!receipt) {
      return reply.status(400).send({
        error: 'Invalid Receipt',
        message: 'Could not parse payment receipt',
      });
    }

    const verification = await verifyPayment(receipt);

    if (!verification.valid) {
      return reply.status(402).send({
        error: 'Payment Verification Failed',
        message: verification.error,
        requirements: PAYMENT_REQUIREMENTS,
      });
    }

    // Payment verified - allow request to proceed
    (request as any).paymentReceipt = receipt;
  });

  done();
};