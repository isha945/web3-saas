
    // Dune Analytics API Client
    // Generated by Cradle - Feature: wallet-balances
    
    const DUNE_API_BASE = 'https://api.dune.com/api/v1';
    
    // Core Types
    export interface DuneExecuteParams {
      sql: string;
      performance?: 'medium' | 'large';
      params?: Record<string, string | number>;
    }
    
    export interface DuneExecutionResult {
      execution_id: string;
      state: 'QUERY_STATE_PENDING' | 'QUERY_STATE_EXECUTING' | 'QUERY_STATE_COMPLETED' | 'QUERY_STATE_FAILED' | 'QUERY_STATE_CANCELLED';
    }
    
    export interface DuneQueryResult<T = Record<string, unknown>> {
      execution_id: string;
      query_id: number;
      state: string;
      result: {
        rows: T[];
        metadata: {
          column_names: string[];
          column_types: string[];
          row_count: number;
          result_set_bytes: number;
          total_row_count: number;
        };
      };
    }
    
    
export interface WalletBalance {
  token_address: string;
  symbol: string;
  balance: number;
  value_usd: number;
}
    
    class DuneClient {
      private apiKey: string;
      private cache: Map<string, { data: unknown; expiry: number }> = new Map();
    
      constructor() {
        const key = process.env.NEXT_PUBLIC_DUNE_API_KEY ?? process.env.DUNE_API_KEY;
        if (!key) {
          console.warn('Missing DUNE_API_KEY environment variable');
        }
        this.apiKey = key ?? '';
      }
    
      private getCached<T>(key: string): T | null {
        const cached = this.cache.get(key);
        if (cached && cached.expiry > Date.now()) {
          return cached.data as T;
        }
        this.cache.delete(key);
        return null;
      }
    
      private setCache(key: string, data: unknown, ttlMs: number): void {
        this.cache.set(key, { data, expiry: Date.now() + ttlMs });
      }
    
      
  /**
   * Execute a SQL query on Dune
   */
  async executeSQL(params: DuneExecuteParams): Promise<DuneExecutionResult> {
    const response = await fetch(`${DUNE_API_BASE}/sql/execute`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-DUNE-API-KEY': this.apiKey,
      },
      body: JSON.stringify({
        sql: params.sql,
        performance: params.performance ?? 'medium',
        ...(params.params && { query_parameters: params.params }),
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Dune API error: ${response.status} - ${error}`);
    }

    return response.json();
  }

  /**
   * Get execution status
   */
  async getExecutionStatus(executionId: string): Promise<DuneExecutionResult> {
    const response = await fetch(`${DUNE_API_BASE}/execution/${executionId}/status`, {
      headers: {
        'X-DUNE-API-KEY': this.apiKey,
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Dune API error: ${response.status} - ${error}`);
    }

    return response.json();
  }

  /**
   * Get execution results
   */
  async getExecutionResults<T = Record<string, unknown>>(executionId: string): Promise<DuneQueryResult<T>> {
    const response = await fetch(`${DUNE_API_BASE}/execution/${executionId}/results`, {
      headers: {
        'X-DUNE-API-KEY': this.apiKey,
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Dune API error: ${response.status} - ${error}`);
    }

    return response.json();
  }

  /**
   * Execute query and wait for results
   */
  async executeAndWait<T = Record<string, unknown>>(
    params: DuneExecuteParams,
    options?: { pollInterval?: number; timeout?: number; cacheTtl?: number }
  ): Promise<DuneQueryResult<T>> {
    const cacheKey = JSON.stringify(params);
    const cached = this.getCached<DuneQueryResult<T>>(cacheKey);
    if (cached) return cached;

    const pollInterval = options?.pollInterval ?? 1000;
    const timeout = options?.timeout ?? 60000;
    const startTime = Date.now();

    const execution = await this.executeSQL(params);
    
    while (Date.now() - startTime < timeout) {
      const status = await this.getExecutionStatus(execution.execution_id);
      
      if (status.state === 'QUERY_STATE_COMPLETED') {
        const results = await this.getExecutionResults<T>(execution.execution_id);
        if (options?.cacheTtl) {
          this.setCache(cacheKey, results, options.cacheTtl);
        }
        return results;
      }
      
      if (status.state === 'QUERY_STATE_FAILED' || status.state === 'QUERY_STATE_CANCELLED') {
        throw new Error(`Query ${status.state}`);
      }
      
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }

    throw new Error('Query execution timeout');
  }
      
      
  /**
   * Get wallet token balances
   */
  async getWalletBalances(
    wallet: string,
    blockchain: string,
    minBalanceUsd = 1,
    cacheTtl = 60000
  ): Promise<WalletBalance[]> {
    const sql = `
      SELECT 
        b.token_address,
        m.symbol,
        CAST(b.balance AS DOUBLE) / POWER(10, COALESCE(m.decimals, 18)) as balance,
        (CAST(b.balance AS DOUBLE) / POWER(10, COALESCE(m.decimals, 18))) * COALESCE(p.price, 0) as value_usd
      FROM balances.erc20 b
      LEFT JOIN tokens.erc20 m ON b.token_address = m.contract_address AND b.blockchain = m.blockchain
      LEFT JOIN prices.latest p ON b.token_address = p.contract_address AND b.blockchain = p.blockchain
      WHERE b.address = LOWER('${wallet}')
        AND b.blockchain = '${blockchain}'
        AND (CAST(b.balance AS DOUBLE) / POWER(10, COALESCE(m.decimals, 18))) * COALESCE(p.price, 0) >= ${minBalanceUsd}
      ORDER BY value_usd DESC
    `;

    const result = await this.executeAndWait<WalletBalance>({ sql }, { cacheTtl });
    return result.result.rows;
  }
    }
    
    // Export singleton instance
    export const duneClient = new DuneClient();
    
    // Export class for custom instances
    export { DuneClient };
  